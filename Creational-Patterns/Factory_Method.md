# Factory Method

## 의도

Factory Method는 부모 클래스에서 객체들을 생성할 수 있는 인터페이스를 제공하지만, 자식 클래스들이 생성될 객체들의 유형을 변경할 수 있도록하는 생성 패턴입니다.

![의도](https://refactoring.guru/images/patterns/content/factory-method/factory-method-ko-2x.png)

## 등장배경

물류 관리 앱을 개발하고 있다고 가정할 때, 처음엔 트럭 운송만 처리할 수 있어서 대부분의 코드가 `Truck`에 존재한다. 얼마 후, 해상 물류 기능이 추가된다고 생각해보자

![해상 물류 추가](https://refactoring.guru/images/patterns/diagrams/factory-method/problem1-ko-2x.png)

현재 대부분의 코드는 `Truck`에 강한 의존성이 있다. `Ship`을 추가하려면 전체 코드를 수정해야 한다. 또한, 다른 수단이 추가된다면 또, 전체 코드를 변경해야 한다.

이 때, 앱의 행동을 결정하기 위해, 많은 조건문이 추가되어 매우 복잡한 코드가 작성될 것이다.

## 해결책

팩토리 메서드 패턴은 `new`호출을 이용한 직접 객체 생성을 팩토리 메서드 호출로 대체하는 것이다. 오브젝트는 여전히 `new`연산자에 의해 호출되지만 팩토리 메서드안에 있을 뿐이다. 팩토리 메서드에 리턴된 객체들은 종종 프로덕트라고 불린다.

![class diagram](https://refactoring.guru/images/patterns/diagrams/factory-method/solution1-2x.png)

이러한 변경은 무의미해 보일 수 있는데, 그 이유는 **생성자 호출**을 다른 다른 곳으로 옮겼을 뿐이기 때문이다. 그러나 위와 같은 변경 덕분에 이제 자식 클래스에서 팩토리 메서드를 오버라이딩하고 그 메서드에 의해 **제품 클래스를 변경**할 수 있게 됨

하지만 약간의 제한이 있는데, 오직 서브클래스가 같은 interface나 Base를 가질 때에만, 다른 타입의 프로덕트를 리턴할 수 있다. 또한, Base의 팩토리 메서드는 반드시 인터페이스 타입으로 리턴 타입을 가져야한다.

![same interface](https://refactoring.guru/images/patterns/diagrams/factory-method/solution2-en-2x.png?id=1209a3156e450b9d7c437ca6bb98b219)

예를 `Truck`과 `Ship`클래스는 반드시 `deliver()`를 가지고 있는 `Transport Inteface`를 구현해야 한다. 각각의 클래스는 다르게 다른 방식으로 구현한다. `RoadLogistics`는 트럭을, `ShipLogistics`는 배를 리턴한다.

![같은 인터페이스](https://refactoring.guru/images/patterns/diagrams/factory-method/solution3-en-2x.png?id=542c0ba89e91ac11ea79e94bc0229f70)

종종 클라이언트라 불리우는 팩토리 패서드를 사용하는 코드는 다양한 서브클래스에 의해 리턴되는 실 프로덕트들의 차이점을 알 수 없다. 클라이언트 코드는 모든 프로덕트들을 추상화된 `Transport`취급한다.클라이언트는 모든 이동수단이 `deliver()`메서드를 가지고 있다는 것을 안다. 하지만, 클라이언트에게  어떻게 그것들이 동작하는지는 중요하지 않다.

## 구조

![구조](https://refactoring.guru/images/patterns/diagrams/factory-method/structure-2x.png?id=9ea3aa8a47f8be22e12e523c15b448fd)

## 구조

## 의사코드

UI 구현체와 결합 없이, 크로스 플랫폼 UI를 구성하는데 사용되는 예시를 아래 그림에서 보여준다.

![UI](https://refactoring.guru/images/patterns/diagrams/factory-method/example-2x.png?id=a2470830778e318263155000dbdc5870)

Base `Dialog`는 다이얼로그를 띄우기 위해, OS에 따라 다른 UI 요소를 사용한다. 이 요소들은 보기엔 작은 차이가 있지만, 동작은 동일하다.

팩토리 메서드가 동작할 때, OS별로 다이얼로그의 로직을 재작성할 필요없다. Base `Dialog`에 버튼 생성 팩토리 메서드를 선언하면, 나중에 팩토리 메서드로 윈도우 스타일 버튼을 생성하는 Dialog 자식클래스를 생성하는 것이 가능하다. 그 후, 서브클래스는 대부분의 코드를 Base로부터 상속받아, 윈도우 스타일의 버튼들을 렌더링할 수 있다.

이 때, Base `Dialog` 클래스가 Abstract Button들과 함께 작동해야 한다. 이렇게 해야 다이얼로그 코드가 버튼 유형에 관계 없이 작동가능하다.

물론, 위 접근 방식을 다른 UI 요소들에도 적용할 수 있으나, 새로운 팩토리 메서드를 추가할 때마다, **Abstract Factory**에 가까워진다.

## 적용 사례

**정확한 타입과 의존성을 사전에 알 수 없을 때, 팩토리 메서드 패턴을 사용할 수 있다.**

팩토리 메서드 패턴은 프로덕트 생성과 프로덕트를 사용하는 사용하는 코드를 분리한 것이다. 따라서, 프로덕트 생성 코드를 나머지 코드와 독립적으로 확장하는 것이  쉬워진다.

새 프로덕트 타입을 추가할 때, 오직, 새로운 factory method를 confirm하는 새로운 서브클래스를 만들기만 하면 된다. OCP 원칙을 지킬 수 있음.

**라이브러리나 프레임워크 유저들에게 내부 컴포넌트를 확장하기 위한 방법을 제공하기 위해 팩토리 메서드 패턴을 적용할 수 있다.**

상속은 아마도 라이브러리나 프레임워크의 행위를 확장하기 위한 가장 쉬운 방법이다. 하지만,  프레임워크가 표준 컴포넌트 대신 당신의 커스터마이즈 컴포넌트를 사용하는지 어떻게 아는가?

해결책은 전역적으로 사용되는 프레임워크 컴포넌트 생성 코드를 단일 팩토리 메서드로 줄인 후, 누구나 이 팩토리 메서드를 오버라이드할 수 있게 하는 것이다.

예를 들어, 오픈 소스 UI 프레임워크를 사용하여, 필요한 것은 라운드 버튼이고, 라이브러리는 사각버튼만 제공한다 한다 가정해보자. 또한 메인 UI 프레임워크가 디폴트 대신 custom button을 사용해야 한다 가정해보자.

이를 위해서는, Base 프레임워크를 서브클래싱하여 `UIWithRoundBUttons`를 만들고,  createButton()를 오버라이딩한다. Base class가 Button class를 리턴하는 반면, subclass는 RoundButton을 리턴한다. 이제 UIFramework대신, 자식 클래스인 UIWithRoundButton class를 사용한다.

**기존 객체를 재사용해서, 매번 객체들을 다시 만드는 대신, 시스템 자원을 절약하고자 할 때, 이 패턴을 사용할수 있다.** **like Cache**

이는 파일 시스템, 네트워킹, DB 커넥션 등과 같은 크고, 리소스를 잡아먹는 객체를 다룰 때, 경험하게 된다.

이를 위해 무엇이 선행되어야 하는지 생각해보자

1. 먼저, 생성된 객체들을 추적할 수 있는 Storage를 만들어야 한다.
2. 객체에 대한 요청이 들어오면, 프로그램은 pool에서 놀고있는 오브젝트를 먼저 찾아본다.
3. 그 다음, 클라이언트 코드에게 반환한다.
4. 만약 없으면, 프로그램은 새로 하나 만들고 pool에 추가한다.

이것은 많은 양의 코드이기 때문에, 한 파일 내에 코드를 선언해서  중복 코드를 방지해야 한다.

아마도 가장 편리하고 당연한 이 코드들이 있어야 할 곳은 우리가 재사용하기 위해 시도하는 코드들의 생성자이다. 그러나, 생성자는 항상 새로운 오브젝트를 리턴해야하기 때문에, 이미 존재하는 인스턴스를 리턴할 수 없다.

따라서, 새 객체 생성 뿐 아니라, 인스턴스를 재사용할 수 있는 메서드가 필요하다. 즉, 팩토리 메서드이다.

## 구현방법 

1. 모든 프로덕트들이 같은 인터페이스를 따르게 한다. 이 인터페이스는 모든 프로덕트에게 적용될 수 있어야 한다.

2. creator 클래스안에 빈 팩토리 메서드를 만든다. 리턴 타입은 공통 프로덕트 인터페이스를 confirm해야한다.

3. creator 코드는 제품 생성자들에 대한 모든 참조를 찾는다. 이 참조들은 하나씩 팩토리 메소드에 대한 호출로 교체하면서, 제품 생성 코드를 팩토리 메소드로 추출한다.

   반환된 프로덕트 유형을 제어하기 위해 팩토리 메서드에 임시 매개변수를 추가야하할 수도 있다.

   이 시점에서 팩토리 메서드 코드가 복잡해질 수 있다. 예를 들어, 인스턴스할 제품 클래스를 결정하는 switch문이 있을 수 있다.

4. 이제 팩토리 메서드에 나열된 각 제품 유형에 대한 creator의 집합을 생성한 후, 자식 클래스에서 팩토리 메서드를 오버라이딩하고 기초 메서드에ㅓㅅ 생성자 코드이 적절한 부분을 추출

5. 프로덕트 타입이 너무 많아 모든 자식 클래스들을 만드는 것이 합리적이지 않다면, 자식 클래스들의 기초 클래스의 제어 매개변수를 재사용할 수 도 있다.

   예를 들어, 다음과 같은 클래스 계층 구조가 있다고 해보자.
   Mail
   ㄴ AirMail
   ㄴ GroundMail
   Transport

   ㄴ Plane
   ㄴ Truck
   ㄴ Train
   AirMail은 Plaine만 사용하지만, GroundMail은 Truck과 Train 모두 사용한다. 이 때, TrainMail을 추가하는 대신, GroundMail의 팩토리 메서드에 파라미터를 추가하여 해결할 수 있다.

6. 추출이 모두 끝난 후 베이스 팩토리 메서드가 비어 있으면, abstract화 할 수 있다. 비어 있지 않다면, 그것을 default behavior로 만들 수도 있다.

## 장단점 

### 장점

- 프로덕트와 creator간의 강한 결합을 피할 수 있다.
- SRP. 프로덕트 생성 코드를 다른 곳으로 이동시켜, 유지보수하기 쉽게 만들 수 있다.
- OCP. 기존 클라이언트 코드를 수정하지 않고, 새로운 타입을 추가할 수 있다.

### 단점

- 패턴 구현을 위해 많은 서브클래싱을 해야하기 때문에 복잡해진다. 이에 대한 적절한 예시는, 이미 존재하는 creator 계층 구조에 적용해야할 때이다.

## 다른 패턴과의 관계 

- 많은 디자인들이 이 패턴들로 부터 시작되었다. 더 적은 복잡성과 서브클래싱을 통해 더 커스터마이징이 가능하다. **Abstract Factory**와 **Prototype**, **Builder** 패턴으로 진화함
- **Abstract** **Factory**는 종종 팩토리 메서드 패턴의 집합을 베이스로 한다. 그러나, 또한 Abstract Factory의 구현체 클래스들의 메서드를 구현하기 위해 **Prototype**을 사용할 수도 있다.
- 팩토리 메서드를 Iterator pattern과 함께 사용하여 컬렉션 자식 클래스들이 해당 컬렉션들과 호환되는 다양한 유형의 반복자들을 반환하도록 할 수 있다.
- **Prototype**은 상속을 베이스로 하지 않기 때문에, 상속과 관련된 단점이 없다. 대신, 프로토 타입은 복제된 객체의 복잡한 초기화가 필요하다. 팩토리 메서드는 상속을 기반으로 하지만 초기화 단계가 필요하지 않다.
- Factory Method는 **Tempalte Method**의 특별 버전이다. 동시에 팩토리 메서드는 대규모 템플릿 메서드의 한 스텝의 역할을 수행(serve)할 수 있다.

[팩토리 비교 글](https://refactoring.guru/ko/design-patterns/factory-comparison)

---

### 정의
- 팩토리로 생성 하는 객체들의 기능이나 함수 추가를 위해 추상 팩토리를 가져 가는 것
- 핵심은 팩토리 인터페이스를 가져가는 것. 
- 해당 메소드들은 가지고 있지만, 클래스에 대한 전체적인 기능들은 
