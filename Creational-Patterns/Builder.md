# Builder Pattern
## 의도

빌더는 복잡한 객체를 단계별로 생성할 수 있도록 하는 디자인 패턴. 이 패턴을 사용하면 같은 생성(construction) 코드를 사용하여 다양한 타입과 상태의 객체를 만들 수 있다.
![labor](https://refactoring.guru/images/patterns/content/builder/builder-en-2x.png "asdf")

## 등장 배경

nested 객체와 많은 필드들을 손이 많이 가고, 단계적으로 초기화해야하는 복잡한 객체들을 상상해보라. 이러한 초기화 코드는 많은 파라미터들과 함께 괴물같은 생성자 코드 안에 숨겨져 있다. 또는 클라이언트 코드 안에 흩어져있음.

![house](https://refactoring.guru/images/patterns/diagrams/builder/problem1-2x.png)

예를 들어, 집 객체를 만든다고 생각해보자. 간단한 집을 짓기 위해서, 4개의 벽과, 바닥을 생성하고, 문을 설치하고, 창틀 세트를 맞추고, 지붕을 설치할 필요가 있다. 그런데 만약 더 크고, 더 빛나는 집같은 조건 좋은 집들(난방 시스템, 배관, 전기 등)을 짓는 다고 생각해보자

가장 간단한 해결책은 `House`객체를 확장하고, 다른 구체적 객체를 서브클래싱하여 모든 파라미터 조합의 경우의 수를 커버하는 것이다. 하지만 결국, 결과적으로 상당한 서브 클래스들을 만들게 될 것이다. porch 스타일같은 파라미터가 늘어날 때마다, 더 복잡한 계층구조가 좁작해질 것이다.

`House`객체를 제어하는 모든 가능한 파라미터를 포함하는 생성자를 만들어 해결할 수 있다. 이 방식은 서브클래싱의 필요성은 없어지지만, 다른 문제를 만들어낸다.

![monster construction](https://refactoring.guru/images/patterns/diagrams/builder/problem2-2x.png?id=5e7975a91c0e4f4ba960f908cc9c2ea2)

보통 대부분의 파라미터가 사용되지 않아, 생성자 호출들의 코드가 매우 못생겨진다. 예를 들어, 극소수의 집에만 수영장이 있기 때문에, 대부분의 경우에, 수영장 파라미터는 사용돠지 않는다.

## 해결책

빌더 패턴은 객체에서 생성 코드를 추출하여 `builder` 라는 별도의 객체들로 이동한다.

![Builder](https://refactoring.guru/images/patterns/diagrams/builder/solution1-2x.png?id=a9c2ab02f0b2aca1a7512022194dd113)

이 패턴은 생성을 일련의 단계들로 정리하여, 객체를 생성할 때 `builder`객체를 실행한다. 중요한 점은 모든 단계를 호출할 필요가 없다는 것으로, 필요한 단계만 호출하면 된다.

일부 단계들은 다른 구현들이 필요할 수 있다. 예를 들어, 오두막벽과 성벽은 다른 구현방식이 필요하다.

이 경우, 같은 건축 단계(인터페이스)를 공유하는 다른 빌더를 생성하여 다양한 종류의 객체를 생성할 수 있다.

![다양한 빌더](https://refactoring.guru/images/patterns/content/builder/builder-comic-1-ko-2x.png?id=0a67d6792a55a8351513f9a48a09fcec)

예를 들어, 위의 그림처럼 같은 건축 단계를 공유하는 빌더들이 다양한 종류의 집을 건설할 수 있다. 그러나 위의 예시는, 건축 단계를 호출하는 클라이언트 코드가 공통 인터페이스를 사용하여 빌더들과 상호 작용할수 있는 경우에만 작동한다.

### 디렉터

더 나아가, 제품을 생성하는 데 사용하는 빌더 단계들에 대한 일련의 호출을 디렉터로 추출할 수 있다. 디렉터 클래스는 제작 단계들을 실행하는 순서를 정의하는 반면, 빌더는 이러한 단계들에 대한 구현을 제공한다.

![디렉터](https://refactoring.guru/images/patterns/content/builder/builder-comic-2-ko-2x.png?id=e69c84869dfc53646024e7316f1f4cdf)

디렉터는 필수 구현사항이 아니며, 유저가 클라이언트 코드에서 직접 순서를 호출할 수 있다. 그러나, 디렉터 클래스를 이용하여 다양한 생성 루틴을 지정하여, 프로그램 전체에서 재사용할 수 있다.

또한, 디렉터 클래스를 이용하여, 구체적인 구현 단계를 캡슐화할 수 있다. 즉, 클라이언트는 빌더를 디렉터에 연결시키고, 디렉터를 이용하여 생성하고, 빌더로부터 결과를 얻기만 하면 된다.

## 구조

![빌더 클래스 다이어그램](https://refactoring.guru/images/patterns/diagrams/builder/structure-2x.png?id=dca1b1508e23c266cbedc80ffb84311a)

## Pseudocode

다음 그림 예시는 **어떻게 같은 생성 코드를 재사용**할 수 있는지를 보여준다. 다양한 유형 프로덕트를 생성할 때. 예를 들어 자동차같은, 그리고 동시에 일치하는 메뉴얼을 생성할 때,

![자동차 빌더 패턴](https://refactoring.guru/images/patterns/diagrams/builder/example-ko-2x.png?id=13219fb8281c4e71c578561e218e7075)

자동차는 수백가지 다른 방법을 생성될 수 있다. `Car`객체를 확장하기 보다, 생성자를 추출하여 `Builder`객체로 옮긴다. 이 빌더 객체는 다양한 차 부품을 설정하는 메서드들을 가지고 있다.

만약, 수제 스포츠카같은 차가 필요하다면, 빌더를 직접적으로 이용할 수 있다. 반면에, 기성품들을 만들줄 아는 디렉터 클래스에게 위임할 수도 있다.

당신은 모든 차들이 메뉴얼이 필요하다는 것에 충격을 받을 것이다. 메뉴얼은 모든 기능들을 설명할 수 있어야하고, 다양한 옵션들마다 제각각이다. 이 점이 왜 동일한 생성 프로세스가 자동차와 메뉴얼에 재사용되는 이유이다. 물론, 메뉴얼이 자동차를 만드는 것과 같은 공정이 아니기 때문에 별도의 구체적인 빌더가 필요하다.이 메뉴얼 빌더 클래스는 자동차 빌더 클래와 마찬가지로, 같은 메서드가 사용되지만, 차 부품을 만드는 대신 설명한다. 디 빌더 객체를 디렉터에 넘겨서, 우리는 차와 메뉴얼을 생성할 수 있다.

마지막 파트는 결과물을 fetchig하는 것이다. 금속의 차와 종이 메뉴얼이 연관되어 있음에도 여전히, 매우 다른 것이다. 구체적 프로덕트 객체와 디렉터가 서로 의존하지 않고는 디렉터 클래스안에 결과물을 추출 메서드를 넣을 수 없다. 대신, 우리는 빌더의 생성 코드로부터 결과물을 얻을 수 있다.

# 적용 예시

### 점층적 생성자를 제거하기 위해 빌더를 사용할 수 있다.

10개의 선택적 매개변수가 있는 생성자를 가정해보자. 복잡도를 줄이기 위해, 생성자 오버로드를 하여 더 짧은 버전의 생성자를 여러개 만든다.

빌더 패턴을 이용하여 생성 코드를 추출하여, 문제를 해결할 수 있다.

### 같지만 일부 다른 제품을 생성하는데 사용할 수 있다

일부 세부 사항만 다른 유사한 제품을 만들 수 있다.

기초 빌더 인터페이스는 가능한 모든 생성 단계들을 정의하고, 빌더 구현체는 이러한 단계들을  구현하여 제품의 여러 표현을 생성한다. 한편, 디렉터는 구현 순서를 가이드해준다.

### Composite tree나 복잡한 객체를 생성하는데 사용할 수 있다.

빌더 패턴은 절차적으로 제품을 생성하게 해준다. 최종 결과물을 망치지 않고, 일부 스텝을 지연할 수 있다. 심지어, 객체 tree를 만들어야할 때, 유용하게, 일부 스텝을 반복할 수 있다. 

빌더는 생성 단계들을 수행하는 동안 미완성 제품을 노출하지 않으며, 이는 클라이언트 코드가 불완전한 결과를 가져오는 것을 방지한다.

# 구현방법

1. 모든 제품을 생성하기 위한 공통 생성 단계들을 명확하게 정의할 수 있는지 확인, 그렇지 못하다면, 빌더 패턴을 사용할 수 없음
2. 기초 빌더 인터페이스에 이 단계를 선언
3. 각 제품 표현에 대한 빌더 구현체를 만들고, 해당 생성 단계들을 구현
   생성 결과를 가져오는 메서드를 구현하는 것을 잊지말기. 빌더 인터페이스 내에서 이 메서드를 선언할 수 없는 이유는 다양한 빌더들이 공통 ㅇ니터페이스가 없는 제품들을 생설할 수 있기 때문. 따라서, 이러한 유형의 메서드의 반환 유형이 무엇인지 알 수 없다. 그러나, 단일 계층 구조 제품들을 처리하는 경우 생성 결과를 가져오는 메서드를 기초 인터페이스에 안전하게 추가할수 있다.
4. 디렉터 객체를 고려하면 생성과정을 캡슐화할 수 있다.
5. 클라이언트 코드는 빌더 객체들과 디렉터 객체들을 모두 생성한다. 제작이 시작되기 전에 클라이언트는 빌더 객체를 디렉터에게 전달해야 한다. 일반적으로 디렉터 생성자에 빌더를 주입해서 한 번만 수행함. 또, 다른 접근방식은 빌더가 디렉터의 특정 제품 제작 메서드에 전달되는 것이다.
6. 모든 제품이 같은 인터페이스를 따르는 경우에만, 디렉터로부터 직접 생성 결과를 얻을 수 있다. 그렇지 않으면, 빌더에서 결과를 가져와야 한다.

## 장단점

### 장점

- 생성 단계를 지연시키거나, **재귀적으로** 실행할 수 있음
- 다양한 프로덕트를 만들 때, 생성 코드를 **재사용할** 수 있음
- **SRP**. 비즈니스 로직에서 복잡한 **생성 코드를 분리**시킬 수 있음

### 단점

- 여러개의 클래스가 필요해지므로, 코드의 복잡성이 증가함

# 다른 패턴과의 관계

- 복잡성이 낮고 자식 클래스들을 통해 더 많은 커스터마이징이 가능한 **Factory Method**로 시작해서, 더 유연하고, 더 복잡한 **Abstract Factory, Proto Type 또는 Builder**로 발전함
- Builder는 복잡한 객체들을 단계별로 생성하는데 중점을 둠. **Abstract Factory**는 관련된 객체들의 패밀리들을 생성하는데 중점을 둔다. Abstract Factory는 프로덕트를 즉시 반환하지만, Builder는 제품을 가져오기 전 **추가 생성단계**를 실행할 수 있다.
- **Composite**을 사용할 때, Builder를 사용할 수 있다. 왜냐하면 빌더의 생성 단계들을 **재귀적으로** 프로그래밍할 수 있기 때문.
- Builder와 **Bridge**를 조합할 수 있다. 디렉터 클래스는 추상화의 역할을 하고 다양한 빌더들은 구현의 역할을 함
- Abastract Factory, Builders 및 Proto Type은 모두 **Singletone**으로 구현 가능
