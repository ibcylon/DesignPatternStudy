## 의도
부모 클래스에서 알고리즘의 골격을 정의하고, 해당 알고리즘의 구조를 변경하지 않고 자식 클래스에서 알고리즘의 오버라이드​(재정의)​할 수 있도록 하는 행동 디자인 패턴
!(의도)[https://refactoring.guru/images/patterns/content/template-method/template-method-2x.png]


## 등장배경
회사 문서들을 분석하는 데이터 마이닝 앱을 만들고 있다고 가정해 보자.
사용자들은 앱에 다양한 형식​(PDF, DOC, CSV)​의 문서들을 제공하고 앱은 이러한 문서들에서 일관된 형식으로 의미 있는 데이터를 추출하려고 시도함
!(문제)[https://refactoring.guru/images/patterns/diagrams/template-method/problem-2x.png]
!(문제)[https://refactoring.guru/images/patterns/diagrams/template-method/live-example-2x.png]

추출하는 내용은 동일하지만, 뽑는 방식의 함수가 다를 때, 굳이 새로 구현할 필요가 없음
처리하는 코드는 클래스마다 완전히 다르지만 데이터 처리 및 분석을 위한 코드는 거의 같음. 알고리즘 구조는 그대로 두되, 코드 중복은 제거하는 게 좋음.


## 해결책 
공통적이거나, 뼈대가 되는 부분은 abstract​(추상) 클래스를 통해 ​디폴트​(기본값) 구현함.
알고리즘을 사용하기 위해 클라이언트는 자신의 자식 클래스를 제공해야 하고, 모든 추상 단계를 구현해야 하며, 필요하다면 (템플릿 메서드를 제외한) 선택적 단계 중 일부를 오버라이드​(재정의)​해야함.
!(해결)[https://refactoring.guru/images/patterns/diagrams/template-method/solution-ko-2x.png]


## 구조
추상 클래스는 알고리즘의 단계들의 역할을 하는 메서드들을 선언하며, 이러한 메서드를 특정 순서로 호출하는 실제 템플릿 메서드도 선언합니다. 단계들은 abstract로 선언되거나 일부 디폴트 구현
구상 클래스들은 모든 단계들을 오버라이드함
!(구조)[https://refactoring.guru/images/patterns/diagrams/template-method/structure-2x.png]


## 의사코드
!(의사코드)[https://refactoring.guru/images/patterns/diagrams/template-method/example-2x.png]

## 적용
템플릿 메서드 패턴은 클라이언트들이 알고리즘의 특정 단계들만 확장할 수 있도록 하고 싶을 때, 그러나 전체 알고리즘이나 알고리즘 구조는 확장하지 못하도록 하려고 할 때 사용
거의 같은 알고리즘들을 포함하는 여러 클래스가 있는 경우에 사용하세요. 결과적으로 알고리즘이 변경되면 모든 클래스를 수정


## 구현방법 
#### 1. 모든 자식 클래스에 공통인지 또 어떤 단계들이 항상 고유한지를 고려해 여러 단계로 나눌 수 있는지 확인

#### 2. 추상 기초 클래스를 만들고 알고리즘의 단계들을 표현하는 템플릿 메서드와 추상 메서드들의 집합을 선언. 템플릿 메서드를 final로 만들어 자식 클래스들이 메서드를 오버라이드하지 못하도록 하는 것을 고려하세요.

#### 3. 알고리즘의 각 변형에서 새로운 구상 자식 클래스를 생성. 새로운 구상 자식 클래스는 모든 추상 단계들을 반드시 구현해야 하지만 일부 선택 단계를 오버라이드할 수도 있음


## 장단점 
### 장점
클라이언트들이 대규모 알고리즘의 특정 부분만 오버라이드하도록 하여 그들이 알고리즘의 다른 부분에 발생하는 변경에 영향을 덜 받도록 할 수 있습니다.
 중복 코드를 부모 클래스로 가져올 수 있습니다.


### 단점
일부 클라이언트들은 알고리즘의 제공된 골격에 의해 제한될 수 있습니다.
당신은 자식 클래스를 통해 디폴트 단계 구현을 억제하여 리스코프 치환 원칙을 위반할 수 있습니다.
템플릿 메서드들은 단계들이 더 많을수록 유지가 더 어려운 경향이 있습니다.
리스코드 치환 원칙 : https://blog.itcode.dev/posts/2021/08/15/liskov-subsitution-principle


## 다른 패턴과의 관계 
팩토리 메서드는 템플릿 메서드의 특수화라고 생각할 수 있습니다. 
동시에 대규모 템플릿 메서드의 한 단계의 역할을 팩토리 메서드가 할 수 있습니다.

템플릿 메서드는 상속을 기반으로 합니다. 이 메서드는 자식 클래스들에서 알고리즘의 부분들을 확장하여 변경할 수 있도록 합니다. 
전략 패턴은 합성을 기반으로 합니다: 당신은 객체 행동의 일부분들을 이러한 행동에 해당하는 다양한 전략들을 제공하여 변경할 수 있습니다. 
템플릿 메서드는 클래스 수준에서 작동하므로 정적입니다. 전략 패턴은은 객체 수준에서 작동하므로 런타임에 행동들을 전환할 수 있도록 합니다.
