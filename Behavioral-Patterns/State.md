# Strategy

## 의도

행동 패턴으로 알고리즘 패밀리들을 정의하게 해준다. 각 패밀리를 별도의 클래스에 넣고, 상호교환하게 해주는 패턴이다.

![전략 패턴](https://refactoring.guru/images/patterns/content/strategy/strategy-2x.png)

## 등장배경

여행자들을 위한 네비게이션 앱을 만든다고 해보자. 그들을 도시로 빠르게 이끌기 위해 지도를 중앙에 이쁘게 배치한다.

가장 많이 요청받은 기능 중 하나는 자동 경로 예측이다. 유저가 주소를 입력하면 가장 빠른 경로를 지도 위에 보여준다.

첫번째 버전은 길 위에 경로를 보여준다. 차를 이용하는 사람은 잘 사용한다. 하지만 모든 여행자들이 차를 사용하지는 않는다. 그래서 다음 업데이트에는 도보 경로를 추가한다. 직후에, 대중 교통을 추가한다.

그러나, 이것은 시작일 뿐이다. 자전거 경로를 추가하고, 이후에 또, 여행 장소를 경유하는 경로를 추가한다.

<img src="https://refactoring.guru/images/patterns/diagrams/strategy/problem-2x.png" alt="mess" title="a" style="zoom:50%;" />

비즈니스 관점에서 앱은 성공적이지만, 기술적인 관전에서 볼 때, 두통을 유발한다. 매번 새로운 알고리즘을 추가할 때마다, 메인 클래스는 사이즈가 두배로 커진다. 어느 지점에 가면, 이 괴물은 유지보수하기 어려워진다.

한 알고리즘을 변경하게 되면, 간단한 버그나 약간의 조정등, 전체 클래스에 영향을 미친다. 프로덕션 코드에 에러를 유발할 가능성이 커지게 된다.

게다가, 팀워크 효율을 낮춘다. 릴리즈를 마친 직후, 고용된 팀원이 머지 컨플릭을 해결하는데 너무 많은 시간이 든다고 불평하게 될 것이다. 새로운 기능을 구현하는데 다른 사람이 생성한 코드 때문에 생긴 컨플릭이 있는 동일한 거대한 클래스를 변경할 필요가 생긴다.

## 해결책 

전략패턴은 특정 작업을 다양한 방식으로 수행하는 클래스를 선택한 후, 모든 알고리즘을 `strategies` 클래스로 추출할 것을 제안합니다.

`context`라 불리는 원본은 `strategies`중 하나를 선택하여 참조해야 한다. 원본은 직접 수행하는 대신 일을 전략 객체에 위임한다.

the context에게는 적절한 알고리즘을 선택할 책임이 없다. 대신, 클라이언트가 적절한 전략을 선택한다. 사실, 컨텍스트는 전략을 잘 모른다. 모든 전략들은 같은 인터페이스를 공유하는데, 이것은 캡슐화된 알고리즘을 가진 전략을 trigger하는 하나의 method를 가진다.

이를 통해, context는 전략 구현체에 독립적이기 때문에, 알고리즘을 수정하거나 추가하는데 있어, 다른 전략을 수행하거나 context를 수정할 필요 없다.

![네비게이터](https://refactoring.guru/images/patterns/diagrams/strategy/solution-2x.png)

네비게이션 앱에서, 각 알고리즘은 하나의 method를 가진 각 클래스로 추출된다. 출발지와 도착지를 받아서 경로 포인트들을 리턴한다.

심지어 같은 인자를 받아도 각 라우팅 클래스는 다른 경로를 만드는데, 메인 네비게이터는 어떤 알고리즘이 선택되었는지 상관하지 않는다. 왜냐하면, 네비게이터의 책임은 지도 위에 포인트들을 렌더링하는 것이디 때문이다. context는 활성화된 라우딩 전략들을 변경하는 메서드를 가지고 있다. 그래서 클라이언트는 UI에서 버튼을 통해, 선택된 라우팅 전략을 변경한다.

## 실세계

![공항에 가는 법](https://refactoring.guru/images/patterns/content/strategy/strategy-comic-1-en-2x.png)

공항에 간다고 생각해보자. 버스나 택시를 타거나 혹은 자전거를 탈 수 있다. 이동 수단 전략들이며, 시간이나 예산의 제약에 따라 한 가지를 선택할 수 있다.

## 구조

<img src="https://refactoring.guru/images/patterns/diagrams/strategy/structure-2x.png" alt="다이어그램" style="zoom:60%;" />

1. Context는 전략 인터페이스를 통해 전략 구현체를 참조하고 통신한다.
2. 전략 인터페이스는 전략을 실행하는 단순한 메서드를 가지고 있다.
3. 전략 구현체는 다른 다양한 방식의 알고리즘으로 구현한다. 
4. 컨텍스트는 필요할 때마다 연결된 전략 객체를 통해 알고리즘을 수행한다. 컨텍스트는 어떤 종류의 전략과 일하는지, 알고리즘이 어떻게 수행하는지 알 수 없다.
5. 클라이언트는 전략 구현체를 만들고 컨텍스트에 전달한다. 컨텍스트는 런타임에 전략을 변경할 수 있는 메서드가 있고 이를 이용해 전략을 런타임에 변경한다.

## 적용 

**한 객체에 다른 여러 알고리즘을 적용하고 싶을 때 그리고 런타임에 알고리즘 간의 변경이 필요할 때**

전략 패턴은 런타임에 간접적으로 객체의 행동을 변경할 수 있게 해주는데, 그에 연관된 다른 하위 객체들을 통해서; 즉, 특정한 하위 테스크들을 다른 방식으로 수행할 수 있는 객체들. 

**비슷한 객체들 이지만 특정 행동하는 방식만 다르게 사용할 때**

전략 패턴은 다양한 행위들을 추출해서 클래스 위계로 나눠서 한 개의 클래스로 조합하고 중복 코드를 방지한다.

**컨텍스트 로직에 중요하지 않은 구현 디테일에서 비즈니스 로직을 분리하고 싶을 때**

코드와 내부 데이터 그리고 알고리즘 의존성들을 나머지 코드에서 분리시킬 수 있다. 다양한 클라이언트는 런타임에 알고리즘을 수행하고, 변경하는 간단한 인터페이스를 가지고 있다.

**같은 종류의 다른 알고리즘을 분기하기 위한 어지럽고 거대한 조건문들을 가진 클래스일 때**

모든 알고리즘을 추출해서 다른 클래스로 나누고, 같은 인터페이스를 구현함으로서, 이런 조건문들을 분리할 수 있다. 원본 객체는 모든 알고리즘을 구현하는 대신, 각각의 객체들에게 위임한다. 

## 구현방법 

1. 컨텍스트 클래스에서, 빈번하게 알고리즘이 변경되는지 체크한다. 런타임에 조건문들을 통해 변경하는지 또한 체크한다.
2. 모든 알고리즘에 동일한 전략 인터페이스를 정의한다.
3. 하나씩, 모든 알고리즘을 각각의 클래스로 분리한다. 이들은 모두 같은 전략 인터페이스를 confirm해야한다.
4. 컨텍스트 클래스는 전략 객체를 참조하고 저장해야한다. 전략을 세팅하고 대체하는 메서드를 제공해야한다. 반드시 전략 객체를 인터페이스를 통해서만 사용해야한다. 컨텍스트는 전략이 데이터에 접근하는 인터페이스를 정의할 수도 있다.
5. 클라이언트는 컨텍스트가 수행해야할 적절한 전략과 연관되야한다. 이러한 전략은 클라이언트가 컨텍스트가 수행해야할 주 테스크와 일치해야한다.

## 장단점 

### 장점

- 런타임에 알고리즘을 변경할 수 있다.
- 사용하는 코드와 알고리즘 구현을 분리할 수 있다.
- 상속을 대신해 조합을 사용할 수 있다.
- OCP. 새로운 전략을 기존 코드 수정 없이 사용할 수 있다.

### 단점

- 변경이 잦지 않고, 두어개 정도의 알고리즘이라면, 이 패턴을 이용한 오버엔지니어링할 필요 없다.
- 클라이언트는 반드시 무엇이 적절한 전략인지 알아야한다.
- 모던 언어는 익명 함수에서 적절한 알고리즘을 수행할 수 있게 해주는 함수형 지원이 있으며, 이는 인터페이스와 거대해지는 클래스 없이 이를 가능케 해준다.

## 다른 패턴과의 관계 

- **브릿지**, **상태**, 전략(가끔 **어댑터**)는 비슷한 구조를 가지고 있다. 사실 이 패턴들은 모두 조합 패턴의 일종인데 다른 객체에게 할 일을 위암하는 것이다.
  그러나, 그들은 모두 다른 문제들을 해결한다. 패턴은 특정한 방법으로 코드를 구조화하는 레시피를 제공하는 것에 불과하다. 또한, 같은 문제를 해결하는 패턴을 다른 개발자와 통신할 수 있게 해준다.
- **커맨드**와 전략은 객체와 액션들을 파라미터화하여 사용하기 때문에 비슷해 보이지만, 다른 의도를 가지고 있다.
  - 객체의 명령을 변경하기 위해 커맨드 패턴을 사용할 수 있다. 오퍼레이션의 파라미터는 객체의 필드가 된다. 변경은 큐에 넣음으로써 실행을 미루고, 커맨드의 기록에 저장한다. 그리고 리모트 서비스에 전송한다.
  - 반면에, 전략은 같은 일을 수행하는 다른 방식을 묘사하기 위해 사용한다.
- **데코레이터**는 객체의 겉을 바꾸지만, 전략은 속을 바꾼다.
- **템플릿 메서드**는 상속에 기반한다. 이는 서브클래싱을 통한 확장으로 알고리즘을 변경할 수 있게 한다.  전략은 composite에 기반한다. 행동에 일치하는 다른 전략을 제공함으로써 변경한다. 템플릿 메서드는 class level이고 정적이다 전략은 객체 레벨이고 런타임이다.
- **상태**는 전략 패턴의 확장으로 여겨질 수 있다. 둘 모두 compostion에 기반한다. 수행할 일을 헬퍼 객체에게 위임함으로써 컨텍스트의 행동을 변경한다. 전략은 이 객체들이 모두 독립적이고, 서로를 모른다.
  반면에, 상태는 상태 구현체들간의 독립성을 강제하지않고, 의지에 따라 컨텍스트의 상태를 변경하게 한다.

