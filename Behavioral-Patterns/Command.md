# Command

## 의도

커맨드 패턴은 행동 패턴 중 하나로, 요청을 요청 정보를 가지고 있는 독립 실행 객체로 전환하는 패턴을 말한다. 이 변환을 통해, 요청을 메서드 파라미터로 넘기거나, 요청의 실행을 지연 또는 큐에 넣을 수 있다. 또, 되돌리기를 지원한다.

![이미지](https://refactoring.guru/images/patterns/content/command/command-en-2x.png)

## 등장배경

텍스트 에디터 앱을 만든다 가정해보자. 툴 바 버튼 제작 요청이 왔다 버튼의 핸들러를 어떻게 삽입해야 할까? 가장 간단한 방법은 종류 마다 서브클래싱하는 것이다.

<img src="https://refactoring.guru/images/patterns/diagrams/command/problem2-2x.png" style="zoom:64%;" />

![로직 독립성](https://refactoring.guru/images/patterns/diagrams/command/problem3-en-2x.png)

복사 기능의 경우, 여러 군데에서 불릴 수 있다. context menu, short cut, 툴바 버튼 등. 중복된 코드를 모든 곳에 선언할 수 없다.

## 해결책 

좋은 디자인 패턴은 보통 레이어 분리를 야기시키는 관심사 분리에 기반을 두고 있다. 비즈니스 로직과 UI 분리가 대표적 예이다. UI Layer는 UI를 담당하고, 계산이나 중요하고 복잡한 일은 비즈니스 로직 레이어에서 담당한다.

![layers](https://refactoring.guru/images/patterns/diagrams/command/solution1-en-2x.png)

커맨드 패턴은 이 떄 GUI 객체가 요청을 직접 보내는 대신에, 요청 디테일을 추출한다. 예를 들어, 호출되는 객체, 메서드 이름, 파라미터 리스트를 해당 요청을 발생 시키는 분리된 커맨드 클래스로 옮긴다.

커맨드 객체는 여러 GUI 객체들과 비즈니스 로직 객체와의 연결을 제공한다. 이로써, GUI는 How / Which 비즈니스 로직 객체 인지 알 필요가 없다. GUI 객체는 그저 자세한 요청을 처리하는 커맨드를 발생시킬 뿐이다.

<img src="https://refactoring.guru/images/patterns/diagrams/command/solution2-en-2x.png" alt="trigger command" style="zoom:33%;" />

커맨드는 파라미터가 없는 executre()라는 단일 메서드만을 가진다. 기존의 파라미터는 어떻게 전달될까? 커맨드 객체는 pre-configured되거나 혹은 스스로 얻을 수용력이 있어야 한다.

![Structure](https://refactoring.guru/images/patterns/diagrams/command/solution3-en-2x.png)

 커맨드 객체를 통해 GUI와  비즈니스 로직 레이어 사이의 미들레이어 역할을 할 수 있다. 종속성을 없애고, 커맨드를 교체하기도 쉬워진다.

## 구조

![구조](https://refactoring.guru/images/patterns/diagrams/command/structure-indexed-2x.png)

1. **Sender class (a.k.a invoker)**는 요청을 초기화해야 한다. 커맨드 객체의 참조를 저장한다. 리시버에게 요청을 전달하는 대신 커맨드를 발생시킨다. 커맨드 객체를 만들 책임은 없다. 일반적으로 클라이언트로부터 생성된 커맨드 객체를 얻는다.

2. **Command interface**는 `execute`라는 단일 메서드만을 가진다.

3. **Concrete Command**는 다양한 종류의 요청을 구현한다. 커맨드 구현체는 작업을 수행하는 것이 아니라, 요청을 비즈니스 로직 객체에게 넘겨준다. 그러나, 단순화를 위해 이 클래스들은 합쳐질 수도 있다.

   리시버 객체의 메서드 실행을 위한 파라미터들은 커맨드 객체의 멤버 필드로 선언될 수도 있다. 생성자를 통해 이런 필드를 초기화하여 커맨드 객체를 **immutable**하게 만들 수도 있다.

4. **Receiver**는 비즈니스 로직을 가지고 있다. 거의 모든 객체는 리시버 역할을 할 수 있다. 대부분의 커맨드 객체는 어떻게 리시버에게 요청을 전달할지만 관여(handle)한다. 반면에 리시버는 직접 일을 수행한다.

5. **Client**는 커맨드 객체를 만들고 설정한다. 클라이언트는 반드시 리시버 인스턴스를 포함한, 요청의 모든 파라미터를 커맨드 생성자에게 넘겨야 한다. 이를 통해, 커맨드 결과는 하나 이상의 센더(invoker)에 연관되게 된다.

## 의사코드

<img src="https://refactoring.guru/images/patterns/diagrams/command/example-2x.png" alt="커맨드 히스토리" style="zoom:40%;" />

에디터의 상태를 변화시키는 커맨드들은 해당 커맨드와 관련된 명령을 실행하기 전에, 에디터의 상태를 백업해놓는다. 커맨드가 실행되고나면, 해당 시점의 에디터 상태의 백업 카피와 나란히 커맨드 히스토리로 이동한다.(커맨드 객체들의 스택 구조). 유저가 되돌리기를 누르면, 앱은 히스토리에서 최근 커맨드를 꺼내와, 에디터 상태를 읽어와 복구시킨다.

클라이언트 코드는 커맨드 구현체와 결합하지 않는다. 왜냐하면 커맨드 인터페이스를 통해 커맨드 객체와 소통하기 때문이다. 이런 접근법은 새로운 커맨드를 도입할 때 OCP를 지키게 해준다.

## 적용 

**명령과 함께 객체를 파라미터화하고 싶을 떄 사용**

특정 메서드 호출을 독립적인 객체로 변경할 수 있다. 이를 통해서, 여러가지를 얻을 수 있다.

1. 커맨드를 메서드의 파라미터로 넘길 수 있다.
2. 커맨드를 다른 객체에 저장할 수 있다.
3. 런타임에 변경할 수 있다.

**명령을 큐에 집어 넣어 스케쥴링하고 싶을 때, 원격으로 실행하고 싶을 때**

다른 객체와 마찬가지로, 커맨드 또한 직렬화가 가능한데, 이는 String으로 바꿔 파일이나 DB에 저장할 수 있음을 의미한다. 후에 커맨드 객체로 복구가 가능하다. 따라서, 실행을 지연시켜 스케쥴링할 수 있다. 같은 방식으로, 큐, 로그 또는 네트워크를 통해 명령을 보낼 수 있다.

**되돌릴 수 있는 명령을 구현하고 싶을 때**

undo/redo를 구현할 많은 방법이 있지만, 가장 유명한 방법 중 하나이다.

되돌리기를 구현하기 위해서, 명령 수행 히스토리를 구현해야한다. 히스토리는 커맨드 기록과 함께 어플의 상태 백업을 같이 포함해야 한다.

이 메서드는 2가지의 단점이 있다. 첫째는 상태 중 일부는 private이기 때문에 상태를 저장하기 쉽지 않다. 이 문제는 메멘토 패턴을 이용해 마이그레이션할 수 있다.

두번쨰로, 백업은 RAM을 많이 잡아 먹는다. 따라서, 때때로는 대체방법으로 구현할 수도 있다. 이전 상태로 복구하는 대신, 반대 명령을 수행하는 것이다. 반대 명령은 비용이 드는데, 불가능하거나, 어려울 수 있다.

## 구현방법 

1. 싱글 메소드를 가진 커맨드 인터페이스를 정의
2. 요청들을 추출해서 커맨드 구현체 클래스로 옮긴다. 각 클래스는 실제 리시버 객체의 레퍼런스와 요청을 같이 저장하는 필드를 설정해야한다. 커맨드 객체의 생성자를 통해 설정해야만 한다.
3. 샌더처럼 행동할 클래스를 구분해야한다. 커맨드 객체를 저장할 필드를 이 클래스에 추가한다. 오직 커맨드 인터페이스를 통해서만, 센더는 커맨드들과 통신해야한다. 샌더는 일반적으로 스스로 거맨드 객체를 생성하지 않고, 클라이언트 코드를 통해 얻는다.
4. 센더가 리시버에게 직접적으로 요청하지 않게, 센더가 커맨드를 실행하게 수정한다.
5. 클라이언트는 다음의 순서에 따라 객체를 초기화한다.
   - 리시버 생성
   - 커맨드 생성, 필요에 따라서 리시버와 연관시킨다.
   - 샌더 생성, 연관 있는 커맨드와 연결

## 장단점

### 장점

- SRP. 명령을 수행하는 클래스와 명령을 불러오는 객체와 decoupling
- OCP. 새로운 커맨드를 추가할 때, 기존의 코드를 수정하지 않아도 됨
- undo/redo 구현 가능
- 지연된 명령 실행 가능
- 간단한 명령 집합을 복잡한 객체 하나로 모을 수 있음

### 단점

- sender와 receiver 사이의 새로운 Layer를 생성해야 해서 복잡해진다.

## 다른 패턴과의 관계 

- **vs 책임 연쇄, 커맨드, 중재자, 옵저버 패턴**
  들은 sender와 receiver사이의 요청을 연결시키는 다양한 방법들이 존재한다.

  - 책임 연쇄는 동적으로 연결된 잠재적 리시버가 요청을 처리할 때 까지 순차적으료 요청을 넘긴다.

  - 커맨드는 sender와 receiver 상의 단방향 연결을 구축한다.

  - 중재자는 sender와 receiver 사이의 직접 연결을 제거하고, 강제로 중재자 객체를 통해 간접 통신하도록 만든다.

  - 옵저버 패턴은 리시버가 동적으로, 들어오는 요청에 대해 구독과 구독취소를 가능케한다.

- **vs 책임연쇄**
  Handler는 커맨드 패턴을 이용해 구현할 수 있다. 요청으로 표현할 수도 있는 같은 컨텍스트 메뉴를 통해서 여러 다른 명령을 실행할 수 잇다.

  그러나, 다른 접근 방식도 존재하는데, 요청 그 자체가 커맨드 객체가 될 수도 있다. 같은 명령을 체인으로 연결된 여러 연속된 다른 종류의 컨텍스트에서 실행할 수 있다.

- **with 메멘토**
  "undo"를 구현하는데 동시에 사용할 수 있다. 커맨드 패턴은 다양한 명령을 타겟 객체를 통해 수행하는 책임이 있는데 반해서, 메멘토는 명령이 실행하기 바로 직전에, 상태를 저장한다.

- **vs 전략 **
  둘 다 특정 액션을 위해 파라미터화하기 때문에 둘은 비슷해보인다. 그러나, 둘은 다른 의도를 가지고 있다.

  - 커맨드 패턴을 어떤 명령이라도 객체화할 수 있다. 명령의 파라미터는 해당 객체의 필드가 된다. 이 변환은 명령을 지연 가능케하고, 큐에 담고, 커맨드의 히스토리를 저장하고, 원격 서비스로 보낼 수 있게 한다.
  - 반면에 전략은 일반적으로 같은 일을 하는데 있어서 다른 방법을 원할 때 사용한다. 하나의 컨텍스트 클래스에서 다른 알고리즘으로 변경하고자 할 떄 말이다.

- **with Prototype**
  커맨드의 카피를 히스토리를 저장할 떄 사용할 수 있다.

- **vs Visitor**
  비지터 패턴을 커맨드 패턴의 파워풀 버전으로 사용할 수 있다. 비지터의 객체들은 다른 클래스의 여러 객체들을 통해 명령을 수행할 수 있다.
