# Pattern

구조 패턴 카테고리로 클라이언트는 실제 객체 대신 Proxy 객체를 통해 작업 요청
Proxy는 실제 객체와 클라이언트 사이에 존재하며 대리인 역할을 함

직접 객체에 제어나 접근을 요청하지 않고, 프록시를 통해서 접근과 제어를 요청하며, OCP 개방/폐쇄 원칙을 지킬 수 있음
![프록시](https://thebook.io/img/080326/044.jpg)

## 의도
프록시는 다른 객체에 대한 대체 또는 자리표시자를 제공할 수 있는 구조 디자인 패턴입니다.  ??
프록시는 원래 객체에 대한 접근을 제어하므로, 당신의 요청이 원래 객체에 전달되기 전 또는 후에 무언가를 수행할 수 있도록 합니다.
log을 남긴다거나 접근을 방지할 수 있다.
![의도](https://refactoring.guru/images/patterns/content/proxy/proxy-2x.png)

## 등장배경
객체에 대한 접근을 제한하는 이유는 무엇일까요? 이 질문에 답하기 위하여 방대한 양의 시스템 자원을 소비하는 거대한 객체가 있다고 가정합시다. 이 객체는 필요할 때가 있기는 하지만, 항상 필요한 것은 아닙니다.
>> 카카오톡에 친구 리스트를 보여줄 떄? 많은 리소스가 든다.

당신은 실제로 필요할 때만 이 객체를 만들어서 지연된 초기화를 구현할 수 있습니다. 그러면 객체의 모든 클라이언트들은 어떤 지연된 초기화 코드를 실행해야 하는데, 불행히도 이것은 아마도 많은 코드 중복을 초래할 것입니다.
이상적인 상황에서는 이 코드를 객체의 클래스에 직접 넣을 수 있겠지만, 그게 항상 가능한 것은 아닙니다. 예를 들어 그 클래스가 폐쇄된 타사 라이브러리의 일부일 수 있습니다.
>> 카카오톡 화면에 보이는 친구리스트 몇명만 보이게 하고, 스크롤를 할 떄마다 새롭게 생성한다.
![등장배경](https://refactoring.guru/images/patterns/diagrams/proxy/problem-ko-2x.png)


## 해결책 
프록시 패턴은 원래 서비스 객체와 같은 인터페이스로 새 프록시 클래스를 생성하라고 제안합니다. 그러면 프록시 객체를 원래 객체의 모든 클라이언트들에 전달하도록 앱을 업데이트할 수 있습니다. 클라이언트로부터 요청을 받으면 이 프록시는 실제 서비스 객체를 생성하고 모든 작업을 이 객체에 위임합니다.
![해결책](https://refactoring.guru/images/patterns/diagrams/proxy/solution-ko-2x.png)

보안(Security) : 프록시는 클라이언트가 작업을 수행할 수 있는 권한이 있는지 확인하고 검사 결과가 긍정적인 경우에만 요청을 대상으로 전달한다.

캐싱(Caching) : 프록시가 내부 캐시를 유지하여 데이터가 캐시에 아직 존재하지 않는 경우에만 대상에서 작업이 실행되도록 한다.

데이터 유효성 검사(Data validation) : 프록시가 입력을 대상으로 전달하기 전에 유효성을 검사한다.

지연 초기화(Lazy initialization) : 대상의 생성 비용이 비싸다면 프록시는 그것을 필요로 할때까지 연기할 수 있다.

로깅(Logging) : 프록시는 메소드 호출과 상대 매개 변수를 인터셉트하고 이를 기록한다

원격 객체(Remote objects) : 프록시는 원격 위치에 있는 객체를 가져와서 로컬처럼 보이게 할 수 있다.


## 구조
![구조](https://refactoring.guru/images/patterns/diagrams/proxy/structure-2x.png)
1. 서비스 인터페이스는 서비스의 인터페이스를 선언합니다. 
2. 서비스는 어떤 유용한 비즈니스 로직을 제공하는 클래스
3. 프록시 클래스에는 서비스 객체를 가리키는 참조 필드가 있습니다. 프록시가 요청의 처리​(예: 초기화 지연, 로깅, 액세스 제어, 캐싱 등)​를 완료하면, 그 후 처리된 요청을 서비스 객체에 전달합니다. 일반적으로 프록시들은 서비스 객체들의 전체 수명 주기를 관리합니다.

4.클라이언트는 같은 인터페이스를 통해 서비스들 및 프록시들과 함께 작동해야 합니다. 그러면 서비스 객체를 기대하는 모든 코드에 프록시를 전달할 수 있기 때문입니다.

Service : 원본 대상 객체
Proxy : 대상 객체(Service)를 중계할 대리자 역할
ServiceInterface : Proxy와 Service 하나로 묶는 인터페이스 (다형성)

Client : ServiceInterface 인터페이스를 이용하여 프록시 객체를 생성해 이용.

클라이언트는 프록시를 중간에 두고 프록시를 통해서 Service 데이터를 주고 받는다.

대상 객체와 프록시 역할을 동일하게 하는 추상 메소드 operation() 를 정의한다.
인터페이스가 있기 때문에 클라이언트는 Proxy 역할과 Service 역할의 차이를 의식할 필요가 없다.

프록시는 대상 객체를 합성(composition)한다.
프록시는 대상 객체와 같은 이름의 메서드를 호출하며, 별도의 로직을 수행 할수 있다 (인터페이스 구현 메소드)
프록시는 흐름제어만 할 뿐 결과값을 조작하거나 변경시키면 안 된다.





## 의사코드
![의사코드](https://refactoring.guru/images/patterns/diagrams/proxy/example-2x.png)

## 적용 
 #### 지연된 초기화​(가상 프록시). 이것은 어쩌다 필요한 무거운 서비스 객체가 항상 가동되어 있어 시스템 자원들을 낭비하는 경우입니다.

 앱이 시작될 때 객체를 생성하는 대신, 객체 초기화를 실제로 초기화가 필요한 시점까지 지연할 수 있습니다.

 #### 접근 제어 (보호 프록시). 당신이 특정 클라이언트들만 서비스 객체를 사용할 수 있도록 하려는 경우에 사용할 수 있습니다. 예를 들어 당신의 객체들이 운영 체제의 중요한 부분이고 클라이언트들이 다양한 실행된 응용 프로그램​(악의적인 응용 프로그램 포함)​인 경우입니다.

 이 프록시는 클라이언트의 자격 증명이 어떤 정해진 기준과 일치하는 경우에만 서비스 객체에 요청을 전달할 수 있습니다.

 #### 원격 서비스의 로컬 실행 (원격 프록시). 서비스 객체가 원격 서버에 있는 경우입니다.

 이 경우 프록시는 네트워크를 통해 클라이언트 요청을 전달하여 네트워크와의 작업의 모든 복잡한 세부 사항을 처리합니다.

  #### 요청들의 로깅​(로깅 프록시). 서비스 객체에 대한 요청들의 기록을 유지하려는 경우입니다.

 프록시는 각 요청을 서비스에 전달하기 전에 로깅​(기록)​할 수 있습니다.

  #### 요청 결과들의 캐싱​(캐싱 프록시). 이것은 클라이언트 요청들의 결과들을 캐시하고 이 캐시들의 수명 주기를 관리해야 할 때, 특히 결과들이 상당히 큰 경우에 사용됩니다.

 프록시는 항상 같은 결과를 생성하는 반복 요청들에 대해 캐싱을 구현할 수 있습니다. 프록시는 요청들의 매개변수들을 캐시 키들로 사용할 수 있습니다.

  #### 스마트 참조. 이것은 사용하는 클라이언트들이 없어 거대한 객체를 해제할 수 있어야 할 때 사용됩니다.

 프록시는 서비스 객체 또는 그 결과에 대한 참조를 얻은 클라이언트들을 추적할 수 있습니다. 때때로 프록시는 클라이언트들을 점검하여 클라이언트들이 여전히 활성 상태인지를 확인할 수 있습니다. 클라이언트 리스트가 비어 있으면 프록시는 해당 서비스 객체를 닫고 그에 해당하는 시스템 자원을 확보할 수 있습니다.

또 프록시는 클라이언트가 서비스 객체를 수정했는지도 추적할 수 있으며, 변경되지 않은 객체는 다른 클라이언트들이 재사용할 수 있습니다.


## 구현방법 
1. 기존 서비스 인터페이스가 없는 경우, 서비스 인터페이스를 하나 생성하여 프록시와 서비스 객체 간의 상호 교환을 가능하게 만드세요. 서비스 클래스에서 인터페이스를 추출하는 것이 항상 가능한 것은 아닙니다. 왜냐하면 그 인터페이스를 사용하려면 서비스의 모든 클라이언트를 변경해야 하기 때문입니다. 대신 프록시를 서비스 클래스의 자식 클래스로 만들 수 있으며, 이렇게 하면 서비스의 인터페이스를 상속하게 할 수 있습니다.

2. 프록시 클래스를 만드세요. 이 클래스에는 서비스에 대한 참조를 저장하기 위한 필드가 있어야 합니다. 일반적으로 프록시들은 서비스들의 전체 수명 주기를 생성하고 관리합니다. 또 드물지만, 클라이언트가 서비스를 프록시의 생성자에 전달하는 방식으로 서비스가 프록시에 전달되기도 합니다.

3. 목적에 따라 프록시 메서드들을 구현하세요. 대부분의 경우 프록시는 일부 작업을 수행한 후에 그 작업을 서비스 객체에 위임해야 합니다.

4. 클라이언트가 프록시를 받을지 실제 서비스를 받을지를 결정하는 생성 메서드를 도입하는 것을 고려하세요. 이 메서드는 프록시 클래스의 간단한 정적 메서드이거나 완전한 팩토리 메서드일 수도 있습니다.

5. 서비스 객체에 대해 지연된 초기화 구현을 고려하세요.


## 장단점 
### 장점
1. 클라이언트들이 알지 못하는 상태에서 서비스 객체를 제어할 수 있습니다.
2. 클라이언트들이 신경 쓰지 않을 때 서비스 객체의 수명 주기를 관리할 수 있습니다.
3. 프록시는 서비스 객체가 준비되지 않았거나 사용할 수 없는 경우에도 작동합니다.
4. 개방/폐쇄 원칙. 서비스나 클라이언트들을 변경하지 않고도 새 프록시들을 도입할 수 있습니다.
 
### 단점
1.  새로운 클래스들을 많이 도입해야 하므로 코드가 복잡해질 수 있습니다.
2.  서비스의 응답이 늦어질 수 있습니다.

## 다른 패턴과의 관계 
어댑터는 다른 인터페이스를, 프록시는 같은 인터페이스를, 데코레이터는 향상된 인터페이스를 래핑된 객체에 제공합니다.
