# 브리지 패턴
## 의도
브리지는 큰 클래스 또는 밀접하게 관련된 클래스들의 집합을 두 개의 개별 계층구조​(추상화 및 구현)​로 나눈 후 각각 독립적으로 개발할 수 있도록 하는 구조 디자인 패턴
> 기능 계층, 즉 메서드의 추가 계층과 구현 계층(인터페이스의 구현 계층) 연결하는 방식의 구조 패턴

![브리지](https://github.com/ibcylon/DesignPatternStudy/blob/duhyeuk-4week/Structual-Patterns/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202024-03-30%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.42.49.png?raw=true)


## 등장배경
Circle​(원) 및 Square​(직사각형)​라는 한 쌍의 자식 클래스들이 있는 기하학적 Shape​(모양) 클래스가 있다고 가정해 봅시다. 

이 클래스 계층 구조를 확장하여 색상을 도입하기 위해 Red​(빨간색) 및 Blue​(파란색) 모양들의 자식 클래스들을 만들 계획입니다.

그러나 이미 두 개의 자식 클래스가 있으므로 Blue­Circle​(파란색 원) 및 Red­Square​(빨간색 직사각형)​와 같은 네 가지의 클래스 조합을 만들어야 합니다.

![브리지](https://refactoring.guru/images/patterns/diagrams/bridge/problem-ko-2x.png)

새 색상과 모형을 추가하려면 각 모양 유형별로 하나씩 세 개의 자식 클래스를 만들어야 합니다. 유형들이 많아지면 많아질수록 코드는 점점 복잡해집니다.


## 해결책 
![브리지](https://refactoring.guru/images/patterns/diagrams/bridge/solution-ko-2x.png)
브리지 패턴은 상속에서 객체 합성으로 전환하여 이 문제를 해결하려고 시도합니다. 
이것이 의미하는 바는 차원 중 하나를 별도의 클래스 계층구조로 추출하여 원래 클래스들이 한 클래스 내에서 모든 상태와 행동들을 갖는 대신 새 계층구조의 객체를 참조하도록 한다는 것입니다.

Shape 클래스는 색상 객체들 중 하나를 가리키는 참조 필드를 받습니다. 이제 모양은 연결된 색상 객체에 모든 색상 관련 작업을 위임할 수 있습니다. 

이 참조는 Shape 및 Color 클래스들 사이의 브리지​(다리) 역할을 할 것


## 구조
![브리지](https://refactoring.guru/images/patterns/diagrams/bridge/structure-ko-2x.png)

Abstraction클래스와 그 기능을 추가하는 Refined Abstraction클래스로 기능 계층 클래스가 있고, Implementation이라는 인터페이스를 구현하는 클래스가 있는데, Abstraction클래스에서 Implementation클래스를 참조하는 인스턴스를 통해서 Implmentation의 method 1, 2, 3을 접근함으로써 복잡하게 만들 필요가 없다.

## 의사코드
![브리지](https://refactoring.guru/images/patterns/diagrams/bridge/example-ko-2x.png)

이미지를 보면 Remote클래스에서 Device 참조가 Radio와 TV을 가리키는 것만 바꾸면 되고, Remote을 다시 구현 할 필요도 없고 Device인터페이스는 그대로고 구현 부분에서 Radio와 TV에 따른 함수들만 구현해주어 참조만 하면 되는 방식이다.

## 적용 
>브리지 패턴은 당신이 어떤 기능의 여러 변형을 가진 모놀리식 클래스를 나누고 정돈하려 할 때 사용하세요. (예: 클래스가 다양한 데이터베이스 서버들과 작동할 수 있는 경우).

클래스가 성장할수록 그 작동 방식을 파악하기가 더 어려워지고 해당 클래스를 변경하는 데 더더욱 오랜 시간이 걸립니다. 클래스 기능의 여러 변형 중 하나를 변경하려면 클래스 전체에 걸쳐 여러 가지 변경을 수행해야 할 수 있으며, 이를 수행 중 개발자들은 종종 실수하거나 일부 중요한 부작용들을 해결하지 않기도 합니다.

브리지 패턴을 사용하면 모놀리식 클래스를 여러 클래스 계층구조로 나눌 수 있습니다. 그런 다음 각 계층구조의 클래스들을 다른 계층구조들에 있는 클래스들과는 독립적으로 변경할 수 있습니다. 이 접근 방식은 코드의 유지관리를 단순화하고 기존 코드가 손상될 위험을 최소화합니다.

 >이 패턴은 여러 직교​(독립) 차원에서 클래스를 확장해야 할 때 사용하세요.

 브리지 패턴은 각 차원에 대해 별도의 클래스 계층구조를 추출할 것을 제안합니다. 원래 클래스는 모든 작업을 자체적으로 수행하는 대신 추출된 계층구조들에 속한 객체들에 관련 작업들을 위임합니다.

 >브리지 패턴은 런타임​(실행시간)​에 구현을 전환할 수 있어야 할 때에 사용하세요.

 선택 사항이지만 브리지 패턴을 사용하면 추상화 내부의 구현 객체를 바꿀 수 있으며, 그렇게 하려면 필드에 새 값을 할당하기만 하면 됩니다.

위 항목은 많은 사람이 브리지와 전략 패턴을 혼동하는 주된 이유입니다. 패턴은 클래스의 구조를 설계하는 특정 방법 그 이상의 것이라는 것을 기억하세요. 패턴은 제기되고 있는 문제 및 의도에 대하여도 소통할 수 있습니다.


## 구현방법 
클래스에서 직교 차원들을 식별하세요. 이러한 독립적인 개념들은 추상화/플랫폼, 도메인/인프라, 프런트엔드/백엔드 또는 인터페이스/구현 등일 수 있습니다.

클라이언트가 필요로 하는 작업들을 확인한 후 기초 추상 클래스에서 정의하세요.

모든 플랫폼들에 제공되어야 하는 작업들을 결정하세요. 그 후 추상화에 필요한 작업들을 일반 구현 인터페이스에서 선언하세요.

도메인의 모든 플랫폼에 대해 구상 구현 클래스들을 생성하되 이 클래스들 모두가 구현 인터페이스를 따르도록 하세요.

추상화 클래스 내에서 구현 유형에 대한 참조 필드를 추가하세요. 추상화는 대부분 작업들을 위 필드에서 참조되는 구현 객체에 위임합니다.

상위 수준 논리의 변형들이 여러 개 있는 경우 기초 추상화 클래스를 확장하여 각 변형에 대해 정제된 추상화들을 만드세요.

클라이언트 코드는 구현 객체를 추상화의 생성자에 전달하여 이 객체를 그 생성자에 연관시켜야 합니다. 그 후에 클라이언트는 구현을 잊어버린 후 추상화 객체와만 작업할 수 있습니다.


## 장단점 

#### 장점
1.플랫폼 독립적인 클래스들과 앱들을 만들 수 있습니다.
2.클라이언트 코드는 상위 수준의 추상화를 통해 작동하며, 플랫폼 세부 정보에 노출되지 않습니다.
3.개방/폐쇄 원칙. 새로운 추상화들과 구현들을 상호 독립적으로 도입할 수 있습니다. >> 직접 코드를 접근하는 방식이 아니라 구현 계층의 클래스를 참조하여 접근하는 방식이라 개방/폐쇄 원칙을 따른다.

4.단일 책임 원칙. 추상화의 상위 수준 논리와 구현의 플랫폼 세부 정보에 집중할 수 있습니다.


 #### 단점 
 결합도가 높은 클래스에 패턴을 적용하여 코드를 더 복잡하게 만들 수 있습니다.


## 다른 패턴과의 관계 
브리지는 일반적으로 사전에 설계되며, 앱의 다양한 부분을 독립적으로 개발할 수 있도록 합니다. 반면에 어댑터는 일반적으로 기존 앱과 사용되어 원래 호환되지 않던 일부 클래스들이 서로 잘 작동하도록 합니다.

브리지, 상태, 전략 패턴은 매우 유사한 구조로 되어 있으며, 어댑터 패턴도 이들과 어느 정도 유사한 구조로 되어 있습니다. 위 모든 패턴은 다른 객체에 작업을 위임하는 합성을 기반으로 합니다. 하지만 이 패턴들은 모두 다른 문제들을 해결합니다. 패턴은 특정 방식으로 코드의 구조를 짜는 레시피에 불과하지 않습니다. 왜냐하면 패턴은 해결하는 문제를 다른 개발자들에게 전달할 수도 있기 때문입니다.

당신은 추상 팩토리를 브리지와 함께 사용할 수 있습니다. 이 조합은 브리지에 의해 정의된 어떤 추상화들이 특정 구현들과만 작동할 수 있을 때 유용합니다. 이런 경우에 추상 팩토리는 이러한 관계들을 캡슐화하고 클라이언트 코드에서부터 복잡성을 숨길 수 있습니다.

빌더를 브리지와 조합할 수 있습니다. 디렉터 클래스는 추상화의 역할을 하고 다양한 빌더들은 구현의 역할을 합니다.
