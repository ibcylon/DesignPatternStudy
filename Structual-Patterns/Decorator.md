# Decorator

## 의도

데코레이터는 구조 해턴으로, 특수한 행동을 포함한 특별한 Wrapper 객체들 안에 넣어서 객체를 연결시킨다.

![Wrapper](https://refactoring.guru/images/patterns/content/decorator/decorator-2x.png)

## 등장배경

알림 라이브러리를 사용하고 있다고 상상해보자, 이것은 다른 프로그램이 중요한 이벤트를 유저들에게 알려주는 역할을 한다.

`Notifieer` class에 기반한 초기 버전은 생성자와 `send` method 필드만 가지고 있다. 이 메서드는 클라이언트로부터 메세지 인자를 받을 수 있고 메세지를 (생성자를 통해 노티파이어에게 전달된) 이메일 목록으로 보낸다. 클라이언트 역할을 하는 3rd-party 앱은 노티파이어 객체를 한번 생성하고 설정한 후, 중요한 일이 발생할 때마다 사용하게 되어 있다.

![구조](https://refactoring.guru/images/patterns/diagrams/decorator/problem1-ko-2x.png "ㅁㄴㅇㄹㄴㅇㄹ")

몇몇 부분에서, 이메일 알림 이상의 기능을 유저들은 기대한다. 대부분은 중요한 이슈들을 SMS로 받길 원한다. 다른이들은 Facebookd으로, 회사 유저들은 Slack으로 받길 원한다.

![3rd-party](https://refactoring.guru/images/patterns/diagrams/decorator/problem2-2x.png?id=28b2c8509b4e78c031d728424b876ebc)

얼마나 가능하려면 얼마나 어렵겠는가? `Notifier`를 확장하고, 새로운 추가 알림 기능을 서브 클래스에 추가시킨다. 그러면 클라이언트는 의도된 알림 클래스를 인스턴스하고 다음의 모든 알림에 사용할 것이다.

그러나 누군가가 당연하게 다음과 같이 물을 것이다. "왜 다양한 알림 타입을 한 번에 사용할 수 없나요? 만약 집이 불탄다면, 모든 채널을 통해 알림이 가야합니다."

당신은 여러 알림 서비스를 가진 특별한 하나의 서브클래스를 만들어 이 문제를 해결하려할 것이다. 그러나, 얼마 안가 명백해진다. 이런 접근 방식은 라이브러리 코드 뿐 아니라, client code까지 매우 늘어나게 만든다.

![Bloat codes even client code](https://refactoring.guru/images/patterns/diagrams/decorator/problem3-2x.png?id=abb7a87b521ce97d7661dd9c0b988cc3)

알림 클래스의 수가 도를 넘지 않도록 다른 방법을 찾아야 한다.

## 해결책 

클래스를 확장하는 것은 객체의 행동을 바꿀 필요가 있을 때 가장 먼저 생각나는 방법이다. 그러나 상속은 당신이 명심해야할 사항들이 있다.

- 상속은 정적이다. 런타임에 객체의 행동을 바꿀 수 없다. 다른 서브클래스를 통해 생성된 객체를 통해서만 변경할 수 있다.
- 서브클래스는 오직 한 부모만 가질 수 있다. 대부분 언어에서, 상속은 여러 클래스의 메서드를 가져올 수 없다.

이런 사항들을 상속 대신에 `Aggregation` or `Composition`을 통해 해결할 수 있다.(Aggregation은 contain이고 Compostition은 consist of의 관계이다.). 두개의 대안 모두 거의 같은 방식이다. 한 객체가 다른 객체를 참조하고, 행동들을 위임한다. 상속은 반면에, 객체 자체가 그 행동을 수행하고, 수퍼클래스로부터 그 행동을 상속받는다.

이 새 접근방식을 통해, 쉽게 `Helper`객체를 다른 객체에 연결 시킬 수 있다. 런타임에 다른 행동으로 변경할 수 있다. 객체는 여러 객체의 레퍼런스를 소유하고, 모든 일을 위임함으로써, 다양한 클래스의 행동을 사용할 수 있다. 이 Aggregation/Compostion은 `Deocrator`를 포함한 많은 디자인 패턴들이 녹아있는 키 원칙이다.

![Aggregation/Composition](https://refactoring.guru/images/patterns/diagrams/decorator/solution1-en-2x.png?id=0acaa7d75290a1647f5402bc5d1c03e7)

"Wrapper"는 Decorator를 대체하는 명확한 이름이다. Wrapper는 목표한 객체와 연결된 객체이다. 타겟과 같은 메서드들을 가지고 있고, wrapper가 요청받은 것을 이들에게 위임한다. 그러나, 어떤 행동들을 함으로써, 타겟에게 요청을 보내기 이전 혹은 이후에 결과를 변경한다.

그럼 간단한 wrapper가 언제 Decorator가 되는가? 위에 설명했듯이 타겟 객체와 같은 인터페이스를 가진다. 이는 클라이언트 입장에서 보면 같은 객체라고 볼 수 있다. 이제 참조한 타겟이 인터페이스를 따르는 모든 객체를 허용하게 만든다. 이는 여러 레퍼들 모두 어떤 한 객체를 커버하게 만들어준다. 모든 래퍼들의 행동을 조합해서 더함으로써

알림 서비스의 예를 들어보자. 간단한 이메일 알림 서비스를 가진 베이스 `Notifier`가 있다.   하지만, 다른 알림 메서드들은 decorator안에 있다.

![알림 데코레이터](https://refactoring.guru/images/patterns/diagrams/decorator/solution2-2x.png?id=7775f76b94dbd5cd25f711ce81f59262)

클라이언트 코드는 기본적인 알림 객체를 데코레이터들로 감싸기만하면 된다. 결과적으로 Stack 구조가 된다.

<img src="https://refactoring.guru/images/patterns/diagrams/decorator/solution3-en-2x.png?id=9a4ef2b4267685a83d0233d78775497b" alt="Stacked" title="jk" style="zoom:60%;" />

스택안의 가작 마지막 데코레이터가 클라이언트와 같이 실제로 일을 수행하게 된다. 모든 데코레이터가 베이스와 같은 인터페이스를 가지고 있기 때문에, 나머지 클라이언트 코드는 이것이 notifier인지 decorator인지 상관하지 않는다.

같은 인터페이스를 따르는 한, 클라이언트는 커스텀 데코레이터를 만들 수 있다. 메세지 형식 지정 도는 수신자 리스트 조합 등

## 실제 세계

![옷](https://refactoring.guru/images/patterns/content/decorator/decorator-comic-1-2x.png?id=ba869f621b6e0ea173fdc2b535fc7eed)

추울 때 옷을 입는 행위가 데코레이터와 같다. 입는 다라는 행위를 확장하여 스웨터 또는 우비를 입을 수 있다.

## 구조 

<img src="https://refactoring.guru/images/patterns/diagrams/decorator/structure-2x.png?id=3cfa1f10417a4ef0c12580bc4a63b80d" alt="구조" title="a" style="zoom:50%;" />

1. 컴포넌트와 데코레이터 공통 인터페이스 작성
2. 컴포넌트 구현체 작성
3. 컴포넌트 target을 가진 데코레이터 인터페이스 작성
4. 데코레이터 구현체 작성

## 의사코드

<img src="https://refactoring.guru/images/patterns/diagrams/decorator/example-2x.png?id=4891323a27d5601a174eec366187d833" alt="data encrypted" style="zoom:50%;" />

앱은 데코레이터 짝으로 데이터 소스 객체를 감쌌다. 두 래퍼는 디스크에 읽고 쓰는 방식에 차이를 두었다.

- 데이터를 쓰기 전에 암호화하고, 압축한다. 원본은 이를 알지 못하고 암호화된 데이터를 쓴다.
- 데이터를 읽어들인 후, 같은 데코레이터를 통해 압축해제하고, 복호화한다.

## 적용 

**코드 수정 없이 런타임에 행동을 추가하고 싶을 때 사용한다.** 

이 패턴은 비즈니스 로직을 레이어들에 넣고 싶을 때 구성하게 해준다. 각 레이어마다 데코레이터를 만들고, 객체를 조합한다. 런타임에 다양한 로직을 조합해서. 클라이언트 코드는 이런 객체들을 같은 방식으로 취급한다. 같은 인터페이스를 공유하기 때문에.

**상속을 통해 확장하기 힘들 때 이 패턴을 사용한다.**

많은 언어에서 `final`키워드를 지원하는데 이는 더 이상의 확장을 금지한다. 이 때 데코레이터 패턴을 이용하여 객체를 wrapping하여 해결할 수 있다.

## 구현방법 

1. 비즈니스 도메인이 여러 선택적 레이어를 가진 기본 컴포넌트로 표현될 수 있는지 검토
2. 기본 컴포넌트와 선택적 레이어들간의 공통 메서드를 추출해라. 컴포넌트 인터페이스를 정의하고 이 메서드들을 여기 선언해라
3. 기본 행위를 기본 컴폰넌트 구현체에 정의
4. 기본 컴포넌트를 참조하는 베이스 데코레이터 정의. 이 때 참조타입은 데코레이터와 컴포넌트를 연결하기 위해 컴포넌트 인터페이스.
5. 모든 클래스들은 같은 인터페이스를 confirm하는걸 보장해야함
6. 베이스 데코레이터를 확장하여, 데코레이터 구현체 생성. 타겟 오브젝트를 호출하기 직전 또는 직후에 추가 행동을 함.
7. 클라이언트 코드는 데코레이터 구현체 생성과 조합을 수행

## 장단점 

### 장점

- 서브클래싱 없이 확장이 가능
- 런타임에 추가/제거가 가능
- 여러 데코레이터들을 조합하여 여러 행동을 조합 가능
- SRP. 다양한 가능한 종류의 행동을 가진 하나의 클래스를 여러개의 작은 클래스로 나눌 수 있음

### 단점

- wrapper stack에서 특정 wrapper 제거하기가 힘듦
- decorator stack에 의존하지 않는 행동을 가진 데코레이터를 정의하기 힘듦
- 레이어 초기 구성 코드가 지저분함



## 다른 패턴과의 관계 

- **어댑터**는 존재하는 객체에 대한 다른 인터페이스를 제공하는데 반해, 데코레이터는 같은 인터페이스 또는 확장된 인터페이스를 사용한다. 게다가, 데코레이터는 재귀적 조합이 가능하다

- **어댑터**는 같은 객체에 다른 인터페이스로 접근하고, **프록시**는 동일한 인터페이스. 데코레이터는 향상된 인터페이스를 사용한다.

- **책임 연쇄**와 데코레이터는 매우 비슷한 구조를 가진다. 둘 다 재귀 조합하여 객체 조합에 실행 코드를 넘기지만 다른 점이 있다.

  책임 연쇄 핸들러는 자유로운 명령들을 각각 독립적으로 실행한다. 특정 구간에서 요청을 멈출 수도 있다. 반면에, 같은 인터페이스 안에서 데코레이터들은 객체의 행동을 확장한다. 게다가, 데코레이터는 요청을 멈출 수 없다.

- Composite과 데코레이터는 비슷한 구조 다이어그램을 가지고 있다. 둘 다 재귀 조합에 의존하여 하나 또는 불특정 다수의 객체들을 정리하기 때문이다.

  데코레이터는 composite과 비슷하지만 하나의 자식 컴포넌트만 가지고 있다. 또 다른 중요한 차이점은 타겟 객체에 다른 책임을 추가할 수 있는데 반해, compsite은 타겟 객체의 결과들을 조합할 뿐이다.

  그러나, 이 패턴들은 협응하기도 한다. composite tree안의 특정 객체를 확장하기 위해 데코레이터를 활용하기도 한다.

- 데코레이터는 오브젝트의 겉을 변경하지만, 전략 패턴은 중심을 변경한다.
- 데코레이터와 프록시는 같은 구조를 가지지만 다른 의도를 가진다. 둘 다 한 객체가 다른 객체의 일을 위임하는 조합 원칙을 가진다. 차이점은 프록시는 일반적으로 해당 서비스의 생명 주기를 자기가 가지지만, 데코레이터들의 조합은 클라이언트에의해 의존한다.